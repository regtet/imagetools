<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>å›¾ç‰‡å¤„ç†å·¥å…·</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet" />
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            color: #333;
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }

        .header p {
            color: #666;
            margin: 10px 0 0 0;
            font-size: 1.1em;
        }

        .tabs {
            display: flex;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            margin-bottom: 20px;
        }

        .tab {
            padding: 15px 30px;
            background: #f8f9fa;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            color: #666;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }

        .tab.active {
            background: #fff;
            color: #0078d4;
            border-bottom-color: #0078d4;
        }

        .tab:hover {
            background: #e9ecef;
            color: #0078d4;
        }

        .tab-content {
            display: none;
            background: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 18px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 600px;
            text-align: center;
        }

        .tab-content.active {
            display: block;
        }

        h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.8em;
            font-weight: 400;
        }

        .drop-area {
            display: flex;
            padding: 30px;
            border: 2px dashed #bbb;
            border-radius: 12px;
            background: #fafafa;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            color: #666;
        }

        .drop-area.hover {
            border-color: #0078d4;
            background: #f0f8ff;
            color: #0078d4;
        }

        .img-container {
            width: 100%;
            max-height: 400px;
            margin: 20px 0;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            background: #fafafa;
        }

        .img-container img,
        .img-container canvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
            margin: auto;
        }

        input[type="number"],
        input[type="text"] {
            width: 100px;
            padding: 8px;
            margin: 0 8px;
            border-radius: 6px;
            border: 1px solid #ccc;
            text-align: center;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: #0078d4;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .control-group label {
            font-weight: 500;
            color: #555;
        }

        button {
            padding: 10px 20px;
            margin: 8px;
            border: none;
            border-radius: 8px;
            background-color: #0078d4;
            color: #fff;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            background-color: #005a9e;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        input[type="file"] {
            display: none;
        }

        .batch-info {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            color: #1976d2;
            font-size: 14px;
        }

        .color-preview {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin: 0 5px;
            border: 2px solid #ddd;
            vertical-align: middle;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>å›¾ç‰‡å¤„ç†å·¥å…·</h1>
        <p>ä¸“ä¸šçš„åœ¨çº¿å›¾ç‰‡ç¼–è¾‘å·¥å…·ï¼Œæ”¯æŒè£å‰ªã€é¢œè‰²æ›¿æ¢ã€æ‰¹é‡é‡å‘½åã€å›¾ç‰‡å åŠ ã€å›¾ç‰‡æ‹¼æ¥ã€GIFåˆ¶ä½œç­‰6å¤§åŠŸèƒ½</p>
    </div>

    <div class="tabs">
        <button class="tab active" data-tab="crop">å›¾ç‰‡è£å‰ª</button>
        <button class="tab" data-tab="replace">é¢œè‰²æ›¿æ¢</button>
        <button class="tab" data-tab="rename">æ‰¹é‡é‡å‘½å</button>
        <button class="tab" data-tab="overlay">å›¾ç‰‡å åŠ </button>
        <button class="tab" data-tab="stitch">å›¾ç‰‡æ‹¼æ¥</button>
        <button class="tab" data-tab="gif">GIFåˆ¶ä½œ</button>
    </div>

    <!-- è£å‰ªå·¥å…· -->
    <div class="tab-content active" id="crop">
        <h2>å›¾ç‰‡è£å‰ªå·¥å…·</h2>
        <label class="drop-area" id="dropCrop">æ‹–æ‹½æˆ–ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡
            <input type="file" id="uploadCrop" accept="image/*">
        </label>

        <div class="img-container">
            <img id="imageCrop" alt="è¯·ä¸Šä¼ å›¾ç‰‡">
        </div>

        <div class="controls">
            <div class="control-group">
                <label>X:</label>
                <input type="number" id="posX" value="55">
            </div>
            <div class="control-group">
                <label>Y:</label>
                <input type="number" id="posY" value="0">
            </div>
            <div class="control-group">
                <label>W:</label>
                <input type="number" id="width" value="341">
            </div>
            <div class="control-group">
                <label>H:</label>
                <input type="number" id="height" value="65">
            </div>
            <button id="applyCrop">åº”ç”¨è£å‰ª</button>
        </div>

        <div style="margin: 15px 0; display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
            <button id="preset1" style="background: #6c757d;">é¢„è®¾1 (55,0,341,65)</button>
            <button id="preset2" style="background: #6c757d;">é¢„è®¾2 (65,0,411,65)</button>
        </div>

        <div id="customPresets"
            style="margin: 15px 0; display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
            <!-- è‡ªå®šä¹‰é¢„è®¾æŒ‰é’®å°†åŠ¨æ€æ’å…¥åˆ°è¿™é‡Œ -->
        </div>

        <div style="margin: 15px 0; display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
            <button id="savePreset" style="background: #28a745;">ä¿å­˜å½“å‰å€¼ä¸ºé¢„è®¾</button>
            <button id="managePresets" style="background: #17a2b8;">ç®¡ç†é¢„è®¾</button>
        </div>

        <div style="display: flex; justify-content: center; gap: 10px; margin-top: 15px;">
            <button id="downloadCrop">ä¸‹è½½è£å‰ªåçš„å›¾ç‰‡</button>
            <button id="resetCrop" style="background: #dc3545;">é‡ç½®å·¥å…·</button>
        </div>
    </div>

    <!-- é¢œè‰²æ›¿æ¢å·¥å…· -->
    <div class="tab-content" id="replace">
        <h2>å›¾ç‰‡é¢œè‰²æ›¿æ¢å·¥å…·</h2>
        <div class="batch-info">
            ğŸ’¡ æ”¯æŒæ‰¹é‡å¤„ç†ï¼šä¸Šä¼ å¤šå¼ å›¾ç‰‡ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨ä¸ºæ¯å¼ å›¾ç‰‡åº”ç”¨ç›¸åŒçš„é¢œè‰²æ›¿æ¢è®¾ç½®<br>
            ğŸ¨ æ”¯æŒå¤šç§é¢œè‰²æ ¼å¼ï¼šåå…­è¿›åˆ¶ï¼ˆ#ff0000ï¼‰ã€å‘½åé¢œè‰²ï¼ˆredã€blueï¼‰ã€RGBï¼ˆrgb(255,0,0)ï¼‰
        </div>

        <label class="drop-area" id="dropReplace">æ‹–æ‹½æˆ–ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡ï¼ˆæ”¯æŒå¤šé€‰ï¼‰
            <input type="file" id="uploadReplace" accept="image/*" multiple>
        </label>

        <div id="imageGrid" style="display: none; margin: 15px 0;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h4 style="margin: 0; color: #333;">å›¾ç‰‡é¢„è§ˆ</h4>
                <span id="uploadCount"
                    style="background: #0078d4; color: #fff; padding: 4px 12px; border-radius: 12px; font-size: 14px; font-weight: 500;"></span>
            </div>
            <div id="gridContainer"
                style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 12px; max-height: 500px; overflow-y: auto; padding: 10px; background: #f8f9fa; border-radius: 8px;">
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>åŸé¢œè‰²:</label>
                <span class="color-preview" id="fromColorPreview" style="background-color: #000000;"></span>
                <input type="text" id="fromColor" value="#000000" placeholder="å¦‚: #000000 æˆ– black">
            </div>
            <div class="control-group">
                <label>ç›®æ ‡é¢œè‰²:</label>
                <span class="color-preview" id="toColorPreview" style="background-color: #ff0000;"></span>
                <input type="text" id="toColor" value="#ff0000" placeholder="å¦‚: #ff0000 æˆ– red">
            </div>
            <div class="control-group">
                <label>å®¹å·®:</label>
                <input type="number" id="tolerance" value="999" min="0" max="441">
            </div>
            <button id="applyReplace" style="background: #0078d4;">åº”ç”¨æ›¿æ¢</button>
        </div>

        <!-- æ›¿æ¢å†å²è®°å½• -->
        <div id="replaceHistory"
            style="display: none; margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
            <h4 style="margin: 0 0 15px 0; color: #333;">æ›¿æ¢å†å²</h4>
            <div id="historyList" style="display: flex; flex-direction: column; gap: 8px;"></div>
            <div style="margin-top: 15px; display: flex; gap: 10px;">
                <button id="undoReplace" style="background: #6c757d; font-size: 14px;" disabled>æ’¤é”€ä¸Šä¸€æ­¥</button>
                <button id="clearHistory" style="background: #dc3545; font-size: 14px;">æ¸…ç©ºå†å²</button>
            </div>
        </div>

        <div style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
            <button id="downloadReplace">ä¸‹è½½å½“å‰å›¾ç‰‡</button>
            <button id="downloadAllReplace" style="display: none;">ä¸‹è½½æ‰€æœ‰å›¾ç‰‡</button>
            <button id="downloadZipReplace" style="display: none; background: #28a745;">ä¸‹è½½å‹ç¼©åŒ…</button>
            <button id="resetReplace" style="background: #dc3545;">é‡ç½®å·¥å…·</button>
        </div>
    </div>

    <!-- æ‰¹é‡é‡å‘½åå·¥å…· -->
    <div class="tab-content" id="rename">
        <h2>æ‰¹é‡é‡å‘½åå›¾ç‰‡åç¼€</h2>
        <div class="batch-info">
            âœï¸ æ‰¹é‡é‡å‘½åï¼šä¸Šä¼ å¤šå¼ å›¾ç‰‡ï¼Œä¸€é”®ä¿®æ”¹æ‰€æœ‰å›¾ç‰‡çš„æ–‡ä»¶åç¼€å<br>
            ğŸ“¦ é¢„è®¾åç¼€ï¼š.pngã€.jpgã€.webpã€.avifã€.bmpã€.gif ç­‰å¸¸ç”¨æ ¼å¼<br>
            âš¡ æ³¨æ„ï¼šä»…ä¿®æ”¹æ–‡ä»¶ååç¼€ï¼Œä¸è¿›è¡Œå®é™…æ ¼å¼è½¬æ¢
        </div>

        <label class="drop-area" id="dropRename">æ‹–æ‹½æˆ–ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡ï¼ˆæ”¯æŒå¤šé€‰ï¼‰
            <input type="file" id="uploadRename" accept="image/*" multiple>
        </label>

        <div id="renameImageGrid" style="display: none; margin: 15px 0;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h4 style="margin: 0; color: #333;">å›¾ç‰‡åˆ—è¡¨</h4>
                <span id="renameUploadCount"
                    style="background: #0078d4; color: #fff; padding: 4px 12px; border-radius: 12px; font-size: 14px; font-weight: 500;"></span>
            </div>
            <div id="renameGridContainer"
                style="max-height: 400px; overflow-y: auto; background: #f8f9fa; border-radius: 8px; padding: 15px;">
            </div>
        </div>

        <div class="controls" style="flex-direction: column; gap: 20px; margin-top: 20px;">
            <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                <button class="format-btn" data-format="png" style="background: #6f42c1;">.png</button>
                <button class="format-btn" data-format="jpg" style="background: #e83e8c;">.jpg</button>
                <button class="format-btn" data-format="jpeg" style="background: #d63384;">.jpeg</button>
                <button class="format-btn" data-format="webp" style="background: #20c997;">.webp</button>
                <button class="format-btn" data-format="avif" style="background: #fd7e14;">.avif</button>
                <button class="format-btn" data-format="bmp" style="background: #6c757d;">.bmp</button>
                <button class="format-btn" data-format="gif" style="background: #17a2b8;">.gif</button>
            </div>

            <div style="display: flex; align-items: center; gap: 10px;">
                <label style="font-weight: 500; color: #555;">ç›®æ ‡åç¼€:</label>
                <select id="targetFormat"
                    style="padding: 8px 15px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; min-width: 120px;">
                    <option value="png">.png</option>
                    <option value="jpg">.jpg</option>
                    <option value="jpeg">.jpeg</option>
                    <option value="webp">.webp</option>
                    <option value="avif">.avif</option>
                    <option value="bmp">.bmp</option>
                    <option value="gif">.gif</option>
                </select>
            </div>
        </div>

        <div style="display: flex; justify-content: center; gap: 10px; margin-top: 20px;">
            <button id="downloadAllRenamed" style="display: none;">ä¸‹è½½æ‰€æœ‰é‡å‘½ååçš„å›¾ç‰‡</button>
            <button id="resetRename" style="background: #dc3545;">é‡ç½®å·¥å…·</button>
        </div>
    </div>

    <!-- å›¾ç‰‡å åŠ å·¥å…· -->
    <div class="tab-content" id="overlay">
        <h2>å›¾ç‰‡å åŠ å·¥å…·</h2>
        <div class="batch-info">
            ğŸ–¼ï¸ å›¾ç‰‡å åŠ ï¼šå°†ä¸€å¼ å›¾ç‰‡å åŠ åˆ°å¦ä¸€å¼ å›¾ç‰‡ä¸Šï¼Œå¯è‡ªç”±è°ƒæ•´ä½ç½®å’Œå¤§å°<br>
            ğŸ¯ æ‹–æ‹½å®šä½ï¼šç›´æ¥æ‹–æ‹½å åŠ å›¾ç‰‡åˆ°ç›®æ ‡ä½ç½®<br>
            ğŸ“ å°ºå¯¸è°ƒæ•´ï¼šæ‹–æ‹½å››ä¸ªè§’è°ƒæ•´å¤§å°ï¼Œè‡ªåŠ¨ä¿æŒçºµæ¨ªæ¯”
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div>
                <h4 style="margin: 0 0 10px 0; color: #333; text-align: center;">èƒŒæ™¯å›¾ç‰‡</h4>
                <label class="drop-area" id="dropBackground" style="padding: 20px; font-size: 14px;">
                    æ‹–æ‹½æˆ–ç‚¹å‡»ä¸Šä¼ èƒŒæ™¯å›¾
                    <input type="file" id="uploadBackground" accept="image/*">
                </label>
            </div>
            <div>
                <h4 style="margin: 0 0 10px 0; color: #333; text-align: center;">å åŠ å›¾ç‰‡</h4>
                <label class="drop-area" id="dropOverlay" style="padding: 20px; font-size: 14px;">
                    æ‹–æ‹½æˆ–ç‚¹å‡»ä¸Šä¼ å åŠ å›¾
                    <input type="file" id="uploadOverlay" accept="image/*">
                </label>
            </div>
        </div>

        <div style="position: relative; margin: 20px 0;">
            <canvas id="overlayCanvas"
                style="max-width: 100%; border: 2px solid #ddd; border-radius: 8px; display: none; cursor: move;"></canvas>
            <div id="overlayPlaceholder"
                style="padding: 60px; text-align: center; border: 2px dashed #ccc; border-radius: 8px; color: #999; background: #fafafa;">
                è¯·å…ˆä¸Šä¼ èƒŒæ™¯å›¾ç‰‡å’Œå åŠ å›¾ç‰‡
            </div>
        </div>

        <div class="controls" style="flex-wrap: wrap;">
            <button id="centerHorizontal" style="background: #6f42c1;" disabled>æ°´å¹³å±…ä¸­</button>
            <button id="centerVertical" style="background: #e83e8c;" disabled>å‚ç›´å±…ä¸­</button>
            <button id="centerBoth" style="background: #20c997;" disabled>å®Œå…¨å±…ä¸­</button>
            <button id="resetOverlay" style="background: #fd7e14;" disabled>é‡ç½®ä½ç½®</button>
            <button id="fitToBackground" style="background: #17a2b8;" disabled>é€‚åº”èƒŒæ™¯</button>
        </div>

        <div class="controls" style="margin-top: 10px;">
            <div class="control-group">
                <label>å åŠ å›¾ä¸é€æ˜åº¦:</label>
                <input type="range" id="overlayOpacity" min="0" max="100" value="100" style="width: 150px;" disabled>
                <span id="opacityValue" style="font-weight: 500; color: #0078d4;">100%</span>
            </div>
        </div>

        <div style="display: flex; justify-content: center; gap: 10px; margin-top: 20px;">
            <button id="downloadOverlay" disabled>ä¸‹è½½åˆæˆåçš„å›¾ç‰‡</button>
            <button id="resetOverlayTool" style="background: #dc3545;">é‡ç½®å·¥å…·</button>
        </div>
    </div>

    <!-- å›¾ç‰‡æ‹¼æ¥å·¥å…· -->
    <div class="tab-content" id="stitch">
        <h2>å›¾ç‰‡æ‹¼æ¥å·¥å…·</h2>
        <div class="batch-info">
            ğŸ–¼ï¸ å›¾ç‰‡æ‹¼æ¥ï¼šå°†å¤šå¼ å›¾ç‰‡æ‹¼æ¥æˆä¸€å¼ å›¾ç‰‡<br>
            ğŸ“ å¤šç§æ¨¡å¼ï¼šæ”¯æŒæ°´å¹³ã€å‚ç›´ã€ç½‘æ ¼æ‹¼æ¥<br>
            âœ¨ æ‹–æ‹½æ’åºï¼šæ‹–æ‹½è°ƒæ•´å›¾ç‰‡é¡ºåº
        </div>

        <label class="drop-area" id="dropStitch">æ‹–æ‹½æˆ–ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡ï¼ˆæ”¯æŒå¤šé€‰ï¼‰
            <input type="file" id="uploadStitch" accept="image/*" multiple>
        </label>

        <div id="stitchImageList" style="display: none; margin: 20px 0;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h4 style="margin: 0; color: #333;">å›¾ç‰‡åˆ—è¡¨ï¼ˆæ‹–æ‹½è°ƒæ•´é¡ºåºï¼‰</h4>
                <span id="stitchUploadCount"
                    style="background: #0078d4; color: #fff; padding: 4px 12px; border-radius: 12px; font-size: 14px; font-weight: 500;"></span>
            </div>
            <div id="stitchListContainer"
                style="display: flex; gap: 10px; flex-wrap: wrap; padding: 15px; background: #f8f9fa; border-radius: 8px; min-height: 100px;">
            </div>
        </div>

        <div class="controls" style="flex-direction: column; gap: 20px; margin-top: 20px;">
            <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                <button class="stitch-mode-btn" data-mode="horizontal" style="background: #6f42c1;">æ°´å¹³æ‹¼æ¥</button>
                <button class="stitch-mode-btn" data-mode="vertical" style="background: #e83e8c;">å‚ç›´æ‹¼æ¥</button>
                <button class="stitch-mode-btn" data-mode="row2" style="background: #20c997;">ä¸€è¡Œ2ä¸ª</button>
                <button class="stitch-mode-btn" data-mode="row3" style="background: #fd7e14;">ä¸€è¡Œ3ä¸ª</button>
                <button class="stitch-mode-btn" data-mode="row4" style="background: #17a2b8;">ä¸€è¡Œ4ä¸ª</button>
                <button class="stitch-mode-btn" data-mode="row5" style="background: #6c757d;">ä¸€è¡Œ5ä¸ª</button>
            </div>

            <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap; justify-content: center;">
                <div class="control-group">
                    <label>æ‹¼æ¥æ¨¡å¼:</label>
                    <select id="stitchMode"
                        style="padding: 8px 15px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; min-width: 120px;">
                        <option value="horizontal">æ°´å¹³æ‹¼æ¥</option>
                        <option value="vertical">å‚ç›´æ‹¼æ¥</option>
                        <option value="row2">ä¸€è¡Œ2ä¸ª</option>
                        <option value="row3" selected>ä¸€è¡Œ3ä¸ª</option>
                        <option value="row4">ä¸€è¡Œ4ä¸ª</option>
                        <option value="row5">ä¸€è¡Œ5ä¸ª</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>å›¾ç‰‡é—´è·:</label>
                    <input type="number" id="stitchGap" value="0" min="0" max="100" style="width: 80px;">
                    <span>px</span>
                </div>

                <div class="control-group">
                    <label>èƒŒæ™¯é¢œè‰²:</label>
                    <input type="color" id="stitchBgColor" value="#ffffff"
                        style="width: 50px; height: 34px; border: 1px solid #ccc; border-radius: 6px; cursor: pointer;">
                </div>
            </div>
        </div>

        <div style="margin: 20px 0;">
            <canvas id="stitchCanvas"
                style="max-width: 100%; border: 2px solid #ddd; border-radius: 8px; display: none;"></canvas>
            <div id="stitchPlaceholder"
                style="padding: 60px; text-align: center; border: 2px dashed #ccc; border-radius: 8px; color: #999; background: #fafafa;">
                è¯·å…ˆä¸Šä¼ è‡³å°‘2å¼ å›¾ç‰‡
            </div>
        </div>

        <div style="display: flex; justify-content: center; gap: 10px; margin-top: 20px;">
            <button id="downloadStitch" disabled>ä¸‹è½½æ‹¼æ¥å›¾ç‰‡</button>
            <button id="resetStitch" style="background: #dc3545;">é‡ç½®å·¥å…·</button>
        </div>
    </div>

    <!-- GIFåˆ¶ä½œå·¥å…· -->
    <div class="tab-content" id="gif">
        <h2>GIFåŠ¨ç”»åˆ¶ä½œ</h2>
        <div class="batch-info">
            ğŸ¬ GIFåˆ¶ä½œï¼šå°†å¤šå¼ å›¾ç‰‡åˆæˆä¸ºGIFåŠ¨ç”»<br>
            â±ï¸ å¸§ç‡æ§åˆ¶ï¼šè°ƒæ•´æ¯å¸§çš„æ˜¾ç¤ºæ—¶é•¿<br>
            ğŸ”„ å¾ªç¯æ’­æ”¾ï¼šæ”¯æŒè®¾ç½®å¾ªç¯æ¬¡æ•°
        </div>

        <label class="drop-area" id="dropGif">æ‹–æ‹½æˆ–ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡ï¼ˆæ”¯æŒå¤šé€‰ï¼‰
            <input type="file" id="uploadGif" accept="image/*" multiple>
        </label>

        <div id="gifImageList" style="display: none; margin: 20px 0;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h4 style="margin: 0; color: #333;">å¸§åˆ—è¡¨ï¼ˆæ‹–æ‹½è°ƒæ•´é¡ºåºï¼‰</h4>
                <span id="gifUploadCount"
                    style="background: #0078d4; color: #fff; padding: 4px 12px; border-radius: 12px; font-size: 14px; font-weight: 500;"></span>
            </div>
            <div id="gifListContainer"
                style="display: flex; gap: 10px; flex-wrap: wrap; padding: 15px; background: #f8f9fa; border-radius: 8px; min-height: 100px;">
            </div>
        </div>

        <div class="controls" style="flex-direction: column; gap: 20px; margin-top: 20px;">
            <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                <button class="gif-delay-btn" data-delay="100" style="background: #6f42c1;">æå¿«(100ms)</button>
                <button class="gif-delay-btn" data-delay="200" style="background: #e83e8c;">å¿«é€Ÿ(200ms)</button>
                <button class="gif-delay-btn" data-delay="500" style="background: #20c997;">æ­£å¸¸(500ms)</button>
                <button class="gif-delay-btn" data-delay="1000" style="background: #fd7e14;">æ…¢é€Ÿ(1s)</button>
                <button class="gif-delay-btn" data-delay="2000" style="background: #17a2b8;">å¾ˆæ…¢(2s)</button>
            </div>

            <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap; justify-content: center;">
                <div class="control-group">
                    <label>å¸§å»¶è¿Ÿ:</label>
                    <input type="number" id="gifDelay" value="500" min="50" max="5000" step="50" style="width: 100px;">
                    <span>æ¯«ç§’</span>
                </div>

                <div class="control-group">
                    <label>å›¾ç‰‡è´¨é‡:</label>
                    <input type="range" id="gifQuality" value="10" min="1" max="30" style="width: 150px;">
                    <span id="gifQualityValue" style="font-weight: 500; color: #0078d4;">10</span>
                    <span style="font-size: 12px; color: #666;">ï¼ˆå€¼è¶Šå°è¶Šæ¸…æ™°ï¼‰</span>
                </div>

                <div class="control-group">
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="checkbox" id="gifRepeat" checked style="cursor: pointer;">
                        <span>æ— é™å¾ªç¯</span>
                    </label>
                </div>
            </div>
        </div>

        <div style="margin: 20px 0;">
            <div id="gifPreview"
                style="display: none; text-align: center; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 2px solid #ddd;">
                <h4 style="margin: 0 0 10px 0; color: #333;">GIFé¢„è§ˆ</h4>
                <img id="gifPreviewImg" style="max-width: 100%; border-radius: 8px; border: 2px solid #ddd;" />
            </div>
            <div id="gifPlaceholder"
                style="padding: 60px; text-align: center; border: 2px dashed #ccc; border-radius: 8px; color: #999; background: #fafafa;">
                è¯·å…ˆä¸Šä¼ è‡³å°‘2å¼ å›¾ç‰‡
            </div>
        </div>

        <div id="gifProgress" style="display: none; margin: 20px 0;">
            <div style="background: #e9ecef; border-radius: 8px; overflow: hidden; height: 30px;">
                <div id="gifProgressBar"
                    style="background: linear-gradient(90deg, #0078d4, #00a8ff); height: 100%; width: 0%; transition: width 0.3s; display: flex; align-items: center; justify-content: center; color: #fff; font-size: 14px; font-weight: 500;">
                </div>
            </div>
            <p id="gifProgressText" style="text-align: center; margin: 10px 0 0 0; color: #666; font-size: 14px;"></p>
        </div>

        <div style="display: flex; justify-content: center; gap: 10px; margin-top: 20px;">
            <button id="generateGif" style="background: #28a745;" disabled>ç”ŸæˆGIF</button>
            <button id="downloadGif" disabled>ä¸‹è½½GIF</button>
            <button id="resetGif" style="background: #dc3545;">é‡ç½®å·¥å…·</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gifshot@0.4.5/dist/gifshot.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        /* ======= åº“åŠ è½½æ£€æµ‹ ======= */
        window.addEventListener('load', function () {
            // æ£€æµ‹gifshotæ˜¯å¦åŠ è½½æˆåŠŸ
            setTimeout(() => {
                if (typeof gifshot === 'undefined') {
                    console.warn('GIFåº“æœªåŠ è½½ï¼ŒGIFåˆ¶ä½œåŠŸèƒ½å¯èƒ½ä¸å¯ç”¨');
                    const generateGifBtn = document.getElementById('generateGif');
                    if (generateGifBtn) {
                        generateGifBtn.title = 'GIFåº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢';
                    }
                } else {
                    console.log('GIFåº“åŠ è½½æˆåŠŸ');
                }
            }, 1000);
        });

        /* ======= æ ‡ç­¾é¡µåˆ‡æ¢ ======= */
        document.addEventListener('DOMContentLoaded', function () {
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // ç§»é™¤æ‰€æœ‰æ´»åŠ¨çŠ¶æ€
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));

                    // æ·»åŠ å½“å‰æ ‡ç­¾çš„æ´»åŠ¨çŠ¶æ€
                    tab.classList.add('active');
                    const targetTab = tab.getAttribute('data-tab');
                    document.getElementById(targetTab).classList.add('active');
                });
            });
        });

        /* ======= è£å‰ªå·¥å…· ======= */
        let cropper, cropFileName = "cropped.png";
        const imageCrop = document.getElementById('imageCrop');
        const uploadCrop = document.getElementById('uploadCrop');
        const downloadCrop = document.getElementById('downloadCrop');
        const applyCrop = document.getElementById('applyCrop');
        const preset1Btn = document.getElementById('preset1');
        const preset2Btn = document.getElementById('preset2');
        const savePresetBtn = document.getElementById('savePreset');
        const managePresetsBtn = document.getElementById('managePresets');
        const customPresetsContainer = document.getElementById('customPresets');

        const posX = document.getElementById('posX');
        const posY = document.getElementById('posY');
        const width = document.getElementById('width');
        const height = document.getElementById('height');

        // å›ºå®šé¢„è®¾å€¼
        const CROP_PRESETS = {
            preset1: {
                x: 55,
                y: 0,
                width: 341,
                height: 65
            },
            preset2: {
                x: 65,
                y: 0,
                width: 411,
                height: 65
            }
        };

        // é»˜è®¤ä½¿ç”¨é¢„è®¾1
        const DEFAULT_CROP_VALUES = CROP_PRESETS.preset1;

        // localStorage key
        const CUSTOM_PRESETS_KEY = 'cropCustomPresets';

        // ä»localStorageåŠ è½½è‡ªå®šä¹‰é¢„è®¾
        function loadCustomPresets() {
            const saved = localStorage.getItem(CUSTOM_PRESETS_KEY);
            return saved ? JSON.parse(saved) : [];
        }

        // ä¿å­˜è‡ªå®šä¹‰é¢„è®¾åˆ°localStorage
        function saveCustomPresets(presets) {
            localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(presets));
        }

        // æ¸²æŸ“è‡ªå®šä¹‰é¢„è®¾æŒ‰é’®
        function renderCustomPresets() {
            const customPresets = loadCustomPresets();
            customPresetsContainer.innerHTML = '';

            if (customPresets.length === 0) {
                customPresetsContainer.style.display = 'none';
                return;
            }

            customPresetsContainer.style.display = 'flex';

            customPresets.forEach((preset, index) => {
                const btn = document.createElement('button');
                btn.style.cssText = 'background: #fd7e14; position: relative; padding-right: 35px;';
                btn.innerHTML = `${preset.name || 'è‡ªå®šä¹‰' + (index + 1)} (${preset.x},${preset.y},${preset.width},${preset.height})`;

                btn.addEventListener('click', () => {
                    applyPreset(preset);
                });

                customPresetsContainer.appendChild(btn);
            });
        }

        function handleCropFile(file) {
            if (!file) return;
            cropFileName = file.name.replace(/\.[^/.]+$/, "") + ".png";
            const url = URL.createObjectURL(file);
            imageCrop.src = url;

            if (cropper) cropper.destroy();
            cropper = new Cropper(imageCrop, {
                aspectRatio: NaN,
                viewMode: 1,
                autoCropArea: 0.3,
                crop(event) {
                    posX.value = Math.round(event.detail.x);
                    posY.value = Math.round(event.detail.y);
                    width.value = Math.round(event.detail.width);
                    height.value = Math.round(event.detail.height);
                },
                ready() {
                    cropper.setData(DEFAULT_CROP_VALUES);
                }
            });
        }

        uploadCrop.addEventListener('change', e => handleCropFile(e.target.files[0]));

        // æ‹–æ‹½ä¸Šä¼ 
        const dropCrop = document.getElementById('dropCrop');
        dropCrop.addEventListener('dragover', e => { e.preventDefault(); dropCrop.classList.add('hover'); });
        dropCrop.addEventListener('dragleave', e => { e.preventDefault(); dropCrop.classList.remove('hover'); });
        dropCrop.addEventListener('drop', e => {
            e.preventDefault();
            dropCrop.classList.remove('hover');
            const file = e.dataTransfer.files[0];
            handleCropFile(file);
        });

        applyCrop.addEventListener('click', () => {
            if (!cropper) {
                alert("è¯·å…ˆä¸Šä¼ å›¾ç‰‡");
                return;
            }

            const x = parseInt(posX.value) || 0;
            const y = parseInt(posY.value) || 0;
            const w = parseInt(width.value) || 100;
            const h = parseInt(height.value) || 100;

            cropper.setData({ x, y, width: w, height: h });
        });

        downloadCrop.addEventListener('click', () => {
            if (!cropper) return alert("è¯·å…ˆä¸Šä¼ å›¾ç‰‡");
            const canvas = cropper.getCroppedCanvas();
            canvas.toBlob(blob => {
                const link = document.createElement('a');
                link.download = cropFileName;
                link.href = URL.createObjectURL(blob);
                link.click();
            });
        });

        // åº”ç”¨é¢„è®¾å€¼çš„é€šç”¨å‡½æ•°
        function applyPreset(presetValues) {
            // æ›´æ–°è¾“å…¥æ¡†å€¼
            posX.value = presetValues.x;
            posY.value = presetValues.y;
            width.value = presetValues.width;
            height.value = presetValues.height;

            // å¦‚æœæœ‰å›¾ç‰‡ï¼Œåº”ç”¨è£å‰ª
            if (cropper) {
                cropper.setData(presetValues);
            }
        }

        // é¢„è®¾1æŒ‰é’®
        preset1Btn.addEventListener('click', () => {
            applyPreset(CROP_PRESETS.preset1);
        });

        // é¢„è®¾2æŒ‰é’®
        preset2Btn.addEventListener('click', () => {
            applyPreset(CROP_PRESETS.preset2);
        });

        // ä¿å­˜å½“å‰å€¼ä¸ºé¢„è®¾
        savePresetBtn.addEventListener('click', () => {
            const name = prompt('è¯·è¾“å…¥é¢„è®¾åç§°ï¼š', 'æˆ‘çš„é¢„è®¾');
            if (!name) return;

            const newPreset = {
                name: name,
                x: parseInt(posX.value) || 0,
                y: parseInt(posY.value) || 0,
                width: parseInt(width.value) || 100,
                height: parseInt(height.value) || 100
            };

            const customPresets = loadCustomPresets();
            customPresets.push(newPreset);
            saveCustomPresets(customPresets);
            renderCustomPresets();

            alert('é¢„è®¾å·²ä¿å­˜ï¼');
        });

        // ç®¡ç†é¢„è®¾
        managePresetsBtn.addEventListener('click', () => {
            const customPresets = loadCustomPresets();

            if (customPresets.length === 0) {
                alert('æš‚æ— è‡ªå®šä¹‰é¢„è®¾');
                return;
            }

            let message = 'å½“å‰è‡ªå®šä¹‰é¢„è®¾åˆ—è¡¨ï¼š\n\n';
            customPresets.forEach((preset, index) => {
                message += `${index + 1}. ${preset.name} (${preset.x},${preset.y},${preset.width},${preset.height})\n`;
            });
            message += '\nè¾“å…¥è¦åˆ é™¤çš„é¢„è®¾ç¼–å·ï¼ˆå¤šä¸ªç”¨é€—å·åˆ†éš”ï¼‰ï¼Œæˆ–ç‚¹å‡»å–æ¶ˆè¿”å›ï¼š';

            const input = prompt(message);
            if (!input) return;

            const indexesToDelete = input.split(',').map(i => parseInt(i.trim()) - 1).filter(i => i >= 0 && i < customPresets.length);

            if (indexesToDelete.length === 0) {
                alert('æ²¡æœ‰æœ‰æ•ˆçš„ç¼–å·');
                return;
            }

            // ä»åå¾€å‰åˆ é™¤ï¼Œé¿å…ç´¢å¼•å˜åŒ–
            indexesToDelete.sort((a, b) => b - a).forEach(index => {
                customPresets.splice(index, 1);
            });

            saveCustomPresets(customPresets);
            renderCustomPresets();

            alert(`å·²åˆ é™¤ ${indexesToDelete.length} ä¸ªé¢„è®¾`);
        });

        // é¡µé¢åŠ è½½æ—¶æ¸²æŸ“è‡ªå®šä¹‰é¢„è®¾
        renderCustomPresets();

        // é‡ç½®è£å‰ªå·¥å…·
        const resetCropBtn = document.getElementById('resetCrop');
        resetCropBtn.addEventListener('click', () => {
            if (cropper) {
                cropper.destroy();
                cropper = null;
            }
            imageCrop.src = '';
            uploadCrop.value = '';
            posX.value = 55;
            posY.value = 0;
            width.value = 341;
            height.value = 65;
            cropFileName = "cropped.png";
        });

        /* ======= é¢œè‰²æ›¿æ¢å·¥å…· ======= */
        let uploadedFiles = [];
        let currentFileIndex = 0;
        let processedImages = [];
        let replaceHistoryData = []; // å­˜å‚¨æ›¿æ¢å†å²è®°å½•
        let originalImages = []; // å­˜å‚¨åŸå§‹å›¾ç‰‡æ•°æ®

        const uploadReplace = document.getElementById("uploadReplace");
        const fromColor = document.getElementById("fromColor");
        const toColor = document.getElementById("toColor");
        const toleranceInput = document.getElementById("tolerance");
        const downloadReplace = document.getElementById("downloadReplace");
        const downloadAllReplace = document.getElementById("downloadAllReplace");
        const downloadZipReplace = document.getElementById("downloadZipReplace");
        const applyReplace = document.getElementById("applyReplace");
        const replaceHistory = document.getElementById("replaceHistory");
        const historyList = document.getElementById("historyList");
        const undoReplace = document.getElementById("undoReplace");
        const clearHistory = document.getElementById("clearHistory");
        const fromColorPreview = document.getElementById("fromColorPreview");
        const toColorPreview = document.getElementById("toColorPreview");
        const imageGrid = document.getElementById("imageGrid");
        const gridContainer = document.getElementById("gridContainer");
        const uploadCount = document.getElementById("uploadCount");

        // é¢œè‰²é¢„è§ˆæ›´æ–°
        function updateColorPreviews() {
            try {
                fromColorPreview.style.backgroundColor = fromColor.value;
                toColorPreview.style.backgroundColor = toColor.value;
            } catch (e) {
                console.warn('é¢œè‰²æ ¼å¼å¯èƒ½ä¸æ­£ç¡®:', e);
            }
        }

        fromColor.addEventListener('input', updateColorPreviews);
        toColor.addEventListener('input', updateColorPreviews);

        // åº”ç”¨é¢œè‰²æ›¿æ¢ - æ‰‹åŠ¨è§¦å‘
        function applyColorReplace() {
            if (uploadedFiles.length === 0) return;

            // ä¿å­˜å½“å‰çŠ¶æ€åˆ°å†å²è®°å½•
            const currentState = {
                timestamp: new Date().toLocaleTimeString(),
                fromColor: fromColor.value,
                toColor: toColor.value,
                tolerance: toleranceInput.value,
                processedImages: [...processedImages] // æ·±æ‹·è´å½“å‰å¤„ç†ç»“æœ
            };

            replaceHistoryData.push(currentState);
            updateHistoryDisplay();

            // ä¸ºæ¯å¼ å›¾ç‰‡åˆ›å»ºå¤„ç†åçš„canvas
            uploadedFiles.forEach((file, index) => {
                const img = new Image();
                img.onload = () => {
                    // åˆ›å»ºä¸´æ—¶canvasè¿›è¡Œå¤„ç†
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');

                    tempCanvas.width = img.width;
                    tempCanvas.height = img.height;
                    tempCtx.drawImage(img, 0, 0);

                    // è·å–å›¾åƒæ•°æ®
                    const imgData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    const data = imgData.data;

                    // é¢œè‰²æ›¿æ¢å¤„ç†
                    const [fr, fg, fb] = hexToRgb(fromColor.value);
                    const [tr, tg, tb] = hexToRgb(toColor.value);
                    const tolerance = parseInt(toleranceInput.value) || 0;

                    for (let i = 0; i < data.length; i += 4) {
                        const dr = data[i] - fr;
                        const dg = data[i + 1] - fg;
                        const db = data[i + 2] - fb;
                        const dist = Math.sqrt(dr * dr + dg * dg + db * db);

                        if (dist <= tolerance) {
                            data[i] = tr;
                            data[i + 1] = tg;
                            data[i + 2] = tb;
                        }
                    }

                    // åº”ç”¨å¤„ç†åçš„å›¾åƒæ•°æ®
                    tempCtx.putImageData(imgData, 0, 0);

                    // ä¿å­˜å¤„ç†åçš„å›¾ç‰‡æ•°æ®
                    processedImages[index] = tempCanvas.toDataURL("image/png");

                    // æ›´æ–°ç½‘æ ¼ä¸­å¯¹åº”å›¾ç‰‡çš„æ˜¾ç¤º
                    updateGridImage(index, processedImages[index]);
                };

                img.onerror = () => {
                    console.error('å›¾ç‰‡åŠ è½½å¤±è´¥:', file.name);
                };

                // ä½¿ç”¨å½“å‰å¤„ç†åçš„å›¾ç‰‡ä½œä¸ºè¾“å…¥ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨åŸå§‹å›¾ç‰‡
                if (processedImages[index]) {
                    img.src = processedImages[index];
                } else {
                    img.src = originalImages[index];
                }
            });
        }

        // æ›´æ–°ç½‘æ ¼ä¸­æŒ‡å®šå›¾ç‰‡çš„æ˜¾ç¤º
        function updateGridImage(index, processedImageData) {
            const gridItems = gridContainer.children;
            if (gridItems[index]) {
                const img = gridItems[index].querySelector('img');
                if (img && processedImageData) {
                    img.src = processedImageData;
                }
            }
        }

        // æ›´æ–°å†å²è®°å½•æ˜¾ç¤º
        function updateHistoryDisplay() {
            if (replaceHistoryData.length === 0) {
                replaceHistory.style.display = 'none';
                undoReplace.disabled = true;
                return;
            }

            replaceHistory.style.display = 'block';
            undoReplace.disabled = false;

            historyList.innerHTML = '';

            replaceHistoryData.forEach((record, index) => {
                const historyItem = document.createElement('div');
                historyItem.style.cssText = `
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      background: #fff;
      border-radius: 6px;
      border: 1px solid #dee2e6;
      font-size: 14px;
    `;

                const colorInfo = document.createElement('div');
                colorInfo.style.cssText = 'display: flex; align-items: center; gap: 8px;';

                const fromColorSpan = document.createElement('span');
                fromColorSpan.style.cssText = `
      display: inline-block;
      width: 20px;
      height: 20px;
      border-radius: 4px;
      border: 1px solid #ccc;
      background-color: ${record.fromColor};
    `;

                const arrow = document.createElement('span');
                arrow.textContent = 'â†’';
                arrow.style.cssText = 'color: #666; font-weight: bold;';

                const toColorSpan = document.createElement('span');
                toColorSpan.style.cssText = `
      display: inline-block;
      width: 20px;
      height: 20px;
      border-radius: 4px;
      border: 1px solid #ccc;
      background-color: ${record.toColor};
    `;

                const details = document.createElement('span');
                details.textContent = `${record.fromColor} â†’ ${record.toColor} (å®¹å·®: ${record.tolerance})`;
                details.style.cssText = 'color: #666; margin-left: 8px;';

                const timeInfo = document.createElement('span');
                timeInfo.textContent = record.timestamp;
                timeInfo.style.cssText = 'color: #999; font-size: 12px;';

                colorInfo.appendChild(fromColorSpan);
                colorInfo.appendChild(arrow);
                colorInfo.appendChild(toColorSpan);
                colorInfo.appendChild(details);

                historyItem.appendChild(colorInfo);
                historyItem.appendChild(timeInfo);

                historyList.appendChild(historyItem);
            });
        }

        // æ’¤é”€ä¸Šä¸€æ­¥æ“ä½œ
        function undoLastReplace() {
            if (replaceHistoryData.length === 0) return;

            // ç§»é™¤æœ€åä¸€æ¡è®°å½•
            replaceHistoryData.pop();

            if (replaceHistoryData.length === 0) {
                // å¦‚æœæ²¡æœ‰å†å²è®°å½•ï¼Œæ¢å¤åˆ°åŸå§‹çŠ¶æ€
                processedImages = [...originalImages];
                uploadedFiles.forEach((file, index) => {
                    updateGridImage(index, originalImages[index]);
                });
            } else {
                // æ¢å¤åˆ°ä¸Šä¸€æ­¥çš„çŠ¶æ€
                const lastRecord = replaceHistoryData[replaceHistoryData.length - 1];
                processedImages = [...lastRecord.processedImages];
                uploadedFiles.forEach((file, index) => {
                    updateGridImage(index, processedImages[index]);
                });
            }

            updateHistoryDisplay();
        }

        // æ¸…ç©ºå†å²è®°å½•
        function clearReplaceHistory() {
            replaceHistoryData = [];
            processedImages = [...originalImages];
            uploadedFiles.forEach((file, index) => {
                updateGridImage(index, originalImages[index]);
            });
            updateHistoryDisplay();
        }

        // é˜²æŠ–å‡½æ•°
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // æ‰‹åŠ¨è§¦å‘é¢œè‰²æ›¿æ¢
        applyReplace.addEventListener('click', applyColorReplace);

        // æ’¤é”€å’Œæ¸…ç©ºå†å²è®°å½•äº‹ä»¶
        undoReplace.addEventListener('click', undoLastReplace);
        clearHistory.addEventListener('click', clearReplaceHistory);

        function handleReplaceFiles(files) {
            console.log('ä¸Šä¼ æ–‡ä»¶æ•°é‡:', files.length);

            if (!files || files.length === 0) {
                console.log('æ²¡æœ‰æ–‡ä»¶ä¸Šä¼ ');
                return;
            }

            // éªŒè¯æ–‡ä»¶ç±»å‹
            const validFiles = Array.from(files).filter(file => {
                const isValid = file.type.startsWith('image/');
                if (!isValid) {
                    console.warn('æ— æ•ˆæ–‡ä»¶ç±»å‹:', file.name, file.type);
                }
                return isValid;
            });

            if (validFiles.length === 0) {
                alert('è¯·ä¸Šä¼ æœ‰æ•ˆçš„å›¾ç‰‡æ–‡ä»¶');
                return;
            }

            uploadedFiles = validFiles;
            processedImages = new Array(validFiles.length);
            originalImages = new Array(validFiles.length);
            replaceHistoryData = []; // æ¸…ç©ºå†å²è®°å½•
            currentFileIndex = 0;

            // ä¿å­˜åŸå§‹å›¾ç‰‡æ•°æ®
            validFiles.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    originalImages[index] = e.target.result;
                    processedImages[index] = e.target.result; // åˆå§‹çŠ¶æ€ä¸ºåŸå§‹å›¾ç‰‡
                };
                reader.readAsDataURL(file);
            });

            console.log('æœ‰æ•ˆæ–‡ä»¶æ•°é‡:', uploadedFiles.length);

            // æ˜¾ç¤ºå›¾ç‰‡ç½‘æ ¼
            imageGrid.style.display = 'block';
            updateImageGrid();

            if (validFiles.length > 1) {
                downloadAllReplace.style.display = 'inline-block';
                downloadZipReplace.style.display = 'inline-block';
            } else {
                downloadAllReplace.style.display = 'none';
                downloadZipReplace.style.display = 'none';
            }

            // ä¸è‡ªåŠ¨åº”ç”¨é¢œè‰²æ›¿æ¢ï¼Œç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨ç‚¹å‡»"åº”ç”¨æ›¿æ¢"æŒ‰é’®
        }

        function updateImageGrid() {
            // æ›´æ–°ä¸Šä¼ æ€»æ•°
            uploadCount.textContent = `${uploadedFiles.length} å¼ `;

            // æ¸…ç©ºç½‘æ ¼
            gridContainer.innerHTML = '';

            // ä¸ºæ¯å¼ å›¾ç‰‡åˆ›å»ºç½‘æ ¼é¡¹
            uploadedFiles.forEach((file, index) => {
                const gridItem = document.createElement('div');
                gridItem.style.cssText = `
      position: relative;
      aspect-ratio: 1;
      border-radius: 8px;
      overflow: hidden;
      background: #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      transition: transform 0.2s ease;
    `;

                const img = document.createElement('img');
                img.style.cssText = `
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    `;

                // æ˜¾ç¤ºåŸå§‹å›¾ç‰‡
                const url = URL.createObjectURL(file);
                img.src = url;

                // æ·»åŠ æ–‡ä»¶åæ ‡ç­¾
                const fileName = document.createElement('div');
                fileName.textContent = file.name.length > 15 ? file.name.substring(0, 15) + '...' : file.name;
                fileName.style.cssText = `
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0,0,0,0.7));
      color: #fff;
      padding: 8px 6px 6px;
      font-size: 11px;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
    `;

                // æ·»åŠ åºå·æ ‡è¯†
                const orderBadge = document.createElement('div');
                orderBadge.textContent = index + 1;
                orderBadge.style.cssText = `
      position: absolute;
      top: 6px;
      left: 6px;
      background: #0078d4;
      color: #fff;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    `;

                gridItem.appendChild(img);
                gridItem.appendChild(fileName);
                gridItem.appendChild(orderBadge);
                gridContainer.appendChild(gridItem);

                // æ·»åŠ æ‚¬åœæ•ˆæœ
                gridItem.addEventListener('mouseenter', () => {
                    gridItem.style.transform = 'scale(1.05)';
                });

                gridItem.addEventListener('mouseleave', () => {
                    gridItem.style.transform = 'scale(1)';
                });
            });
        }

        uploadReplace.addEventListener("change", e => handleReplaceFiles(e.target.files));

        const dropReplace = document.getElementById('dropReplace');
        dropReplace.addEventListener('dragover', e => { e.preventDefault(); dropReplace.classList.add('hover'); });
        dropReplace.addEventListener('dragleave', e => { e.preventDefault(); dropReplace.classList.remove('hover'); });
        dropReplace.addEventListener('drop', e => {
            e.preventDefault();
            dropReplace.classList.remove('hover');
            handleReplaceFiles(e.dataTransfer.files);
        });

        // å°†é¢œè‰²å€¼è½¬æ¢ä¸ºRGBæ•°ç»„ï¼Œæ”¯æŒåå…­è¿›åˆ¶ï¼ˆ#ff0000ï¼‰å’Œå‘½åé¢œè‰²ï¼ˆredï¼‰
        function colorToRgb(color) {
            // å»é™¤ç©ºæ ¼
            color = color.trim();

            // å¦‚æœæ˜¯åå…­è¿›åˆ¶é¢œè‰²
            if (color.startsWith('#')) {
                const hex = color.replace("#", "");
                const bigint = parseInt(hex, 16);
                return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
            }

            // å¦‚æœæ˜¯rgb/rgbaæ ¼å¼
            if (color.startsWith('rgb')) {
                const match = color.match(/\d+/g);
                if (match && match.length >= 3) {
                    return [parseInt(match[0]), parseInt(match[1]), parseInt(match[2])];
                }
            }

            // å¯¹äºå‘½åé¢œè‰²ï¼Œä½¿ç”¨canvasæ¥è½¬æ¢
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = 1;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 1, 1);
            const imageData = ctx.getImageData(0, 0, 1, 1).data;
            return [imageData[0], imageData[1], imageData[2]];
        }

        // ä¿ç•™æ—§å‡½æ•°åä»¥å…¼å®¹
        function hexToRgb(hex) {
            return colorToRgb(hex);
        }

        downloadReplace.addEventListener("click", () => {
            if (uploadedFiles.length === 0) return;
            if (!processedImages[currentFileIndex]) return;

            const link = document.createElement("a");
            const originalName = uploadedFiles[currentFileIndex].name.replace(/\.[^/.]+$/, "");
            const fileName = `${originalName}.png`; // ä¿æŒåŸå§‹æ–‡ä»¶å
            link.download = fileName;
            link.href = processedImages[currentFileIndex];
            link.click();
        });

        downloadAllReplace.addEventListener("click", () => {
            if (uploadedFiles.length === 0) return;

            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å›¾ç‰‡éƒ½å·²å¤„ç†
            const allProcessed = processedImages.every(img => img !== undefined);
            if (!allProcessed) return;

            // æ‰¹é‡ä¸‹è½½æ‰€æœ‰å›¾ç‰‡
            uploadedFiles.forEach((file, index) => {
                setTimeout(() => {
                    const link = document.createElement("a");
                    const originalName = file.name.replace(/\.[^/.]+$/, "");
                    const fileName = `${originalName}.png`; // ä¿æŒåŸå§‹æ–‡ä»¶å
                    link.download = fileName;
                    link.href = processedImages[index];
                    link.click();
                }, index * 200);
            });
        });

        // å‹ç¼©åŒ…ä¸‹è½½åŠŸèƒ½
        downloadZipReplace.addEventListener("click", async () => {
            if (uploadedFiles.length === 0) return;

            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å›¾ç‰‡éƒ½å·²å¤„ç†
            const allProcessed = processedImages.every(img => img !== undefined);
            if (!allProcessed) return;

            // æ£€æŸ¥JSZipæ˜¯å¦åŠ è½½
            if (typeof JSZip === 'undefined') {
                alert('å‹ç¼©åŒ…åŠŸèƒ½éœ€è¦JSZipåº“ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                return;
            }

            try {
                const zip = new JSZip();

                // æ·»åŠ æ‰€æœ‰å¤„ç†åçš„å›¾ç‰‡åˆ°å‹ç¼©åŒ…
                uploadedFiles.forEach((file, index) => {
                    const originalName = file.name.replace(/\.[^/.]+$/, "");
                    const fileName = `${originalName}.png`; // ä¿æŒåŸå§‹æ–‡ä»¶å

                    // å°†base64è½¬æ¢ä¸ºblob
                    const base64Data = processedImages[index].split(',')[1];
                    zip.file(fileName, base64Data, { base64: true });
                });

                // ç”Ÿæˆå‹ç¼©åŒ…
                const zipBlob = await zip.generateAsync({ type: 'blob' });

                // ä¸‹è½½å‹ç¼©åŒ…
                const link = document.createElement('a');
                link.download = 'color_replaced_images.zip'; // ç®€åŒ–çš„å‹ç¼©åŒ…åç§°
                link.href = URL.createObjectURL(zipBlob);
                link.click();

                // æ¸…ç†URL
                setTimeout(() => URL.revokeObjectURL(link.href), 1000);

            } catch (error) {
                console.error('å‹ç¼©åŒ…ç”Ÿæˆå¤±è´¥:', error);
                alert('å‹ç¼©åŒ…ç”Ÿæˆå¤±è´¥ï¼Œè¯·é‡è¯•');
            }
        });

        // é‡ç½®é¢œè‰²æ›¿æ¢å·¥å…·
        const resetReplaceBtn = document.getElementById('resetReplace');
        resetReplaceBtn.addEventListener('click', () => {
            uploadedFiles = [];
            processedImages = [];
            originalImages = [];
            replaceHistoryData = [];
            currentFileIndex = 0;
            uploadReplace.value = '';
            imageGrid.style.display = 'none';
            gridContainer.innerHTML = '';
            replaceHistory.style.display = 'none';
            downloadAllReplace.style.display = 'none';
            downloadZipReplace.style.display = 'none';
            fromColor.value = '#000000';
            toColor.value = '#ff0000';
            toleranceInput.value = 999;
            updateColorPreviews();
        });

        /* ======= æ‰¹é‡é‡å‘½åå·¥å…· ======= */
        let renameFiles = [];

        const uploadRename = document.getElementById("uploadRename");
        const dropRename = document.getElementById("dropRename");
        const renameImageGrid = document.getElementById("renameImageGrid");
        const renameGridContainer = document.getElementById("renameGridContainer");
        const renameUploadCount = document.getElementById("renameUploadCount");
        const targetFormat = document.getElementById("targetFormat");
        const downloadAllRenamed = document.getElementById("downloadAllRenamed");
        const formatBtns = document.querySelectorAll(".format-btn");

        // æ ¼å¼æŒ‰é’®ç‚¹å‡»
        formatBtns.forEach(btn => {
            btn.addEventListener("click", () => {
                const format = btn.getAttribute("data-format");
                targetFormat.value = format;
                if (renameFiles.length > 0) {
                    updateRenameGrid();
                }
            });
        });

        // ç›®æ ‡æ ¼å¼æ”¹å˜
        targetFormat.addEventListener("change", () => {
            if (renameFiles.length > 0) {
                updateRenameGrid();
            }
        });

        // å¤„ç†ä¸Šä¼ çš„æ–‡ä»¶
        function handleRenameFiles(files) {
            if (!files || files.length === 0) return;

            const validFiles = Array.from(files).filter(file => file.type.startsWith('image/'));

            if (validFiles.length === 0) {
                alert('è¯·ä¸Šä¼ æœ‰æ•ˆçš„å›¾ç‰‡æ–‡ä»¶');
                return;
            }

            renameFiles = validFiles;

            renameImageGrid.style.display = 'block';
            downloadAllRenamed.style.display = 'inline-block';

            updateRenameGrid();
        }

        // æ›´æ–°å›¾ç‰‡åˆ—è¡¨æ˜¾ç¤º
        function updateRenameGrid() {
            renameUploadCount.textContent = `å·²ä¸Šä¼  ${renameFiles.length} å¼ `;
            renameGridContainer.innerHTML = '';

            renameFiles.forEach((file, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.style.cssText = `
      display: flex;
      align-items: center;
      background: #fff;
      padding: 12px;
      margin-bottom: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      transition: all 0.3s ease;
    `;

                const img = document.createElement('img');
                img.style.cssText = `
      width: 60px;
      height: 60px;
      object-fit: cover;
      border-radius: 6px;
      margin-right: 15px;
      border: 2px solid #dee2e6;
    `;
                img.src = URL.createObjectURL(file);

                const infoDiv = document.createElement('div');
                infoDiv.style.cssText = `
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 5px;
    `;

                const originalName = document.createElement('div');
                originalName.style.cssText = `
      font-size: 14px;
      color: #666;
      font-weight: 400;
    `;
                originalName.textContent = `åŸæ–‡ä»¶: ${file.name}`;

                const arrow = document.createElement('div');
                arrow.style.cssText = `
      font-size: 16px;
      color: #0078d4;
      font-weight: bold;
    `;
                arrow.textContent = 'â†“';

                const newName = document.createElement('div');
                newName.style.cssText = `
      font-size: 14px;
      color: #0078d4;
      font-weight: 500;
    `;
                newName.id = `newName-${index}`;
                const newFileName = getNewFileName(file.name, targetFormat.value);
                newName.textContent = `æ–°æ–‡ä»¶: ${newFileName}`;

                infoDiv.appendChild(originalName);
                infoDiv.appendChild(arrow);
                infoDiv.appendChild(newName);

                itemDiv.appendChild(img);
                itemDiv.appendChild(infoDiv);

                // æ‚¬åœæ•ˆæœ
                itemDiv.addEventListener('mouseenter', () => {
                    itemDiv.style.transform = 'translateX(5px)';
                    itemDiv.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
                });

                itemDiv.addEventListener('mouseleave', () => {
                    itemDiv.style.transform = 'translateX(0)';
                    itemDiv.style.boxShadow = '0 2px 6px rgba(0,0,0,0.08)';
                });

                renameGridContainer.appendChild(itemDiv);
            });
        }

        // è·å–æ–°æ–‡ä»¶å
        function getNewFileName(originalName, format) {
            const nameWithoutExt = originalName.replace(/\.[^/.]+$/, "");
            return `${nameWithoutExt}.${format}`;
        }

        // æ–‡ä»¶ä¸Šä¼ äº‹ä»¶
        uploadRename.addEventListener("change", e => handleRenameFiles(e.target.files));

        // æ‹–æ‹½ä¸Šä¼ 
        dropRename.addEventListener('dragover', e => {
            e.preventDefault();
            dropRename.classList.add('hover');
        });

        dropRename.addEventListener('dragleave', e => {
            e.preventDefault();
            dropRename.classList.remove('hover');
        });

        dropRename.addEventListener('drop', e => {
            e.preventDefault();
            dropRename.classList.remove('hover');
            handleRenameFiles(e.dataTransfer.files);
        });

        // ä¸‹è½½æ‰€æœ‰é‡å‘½ååçš„å›¾ç‰‡
        downloadAllRenamed.addEventListener("click", () => {
            if (renameFiles.length === 0) return;

            const format = targetFormat.value;

            renameFiles.forEach((file, index) => {
                setTimeout(() => {
                    const link = document.createElement("a");
                    const newFileName = getNewFileName(file.name, format);
                    link.download = newFileName;
                    link.href = URL.createObjectURL(file);
                    link.click();
                }, index * 200);
            });
        });

        // é‡ç½®æ‰¹é‡é‡å‘½åå·¥å…·
        const resetRenameBtn = document.getElementById('resetRename');
        resetRenameBtn.addEventListener('click', () => {
            renameFiles = [];
            uploadRename.value = '';
            renameImageGrid.style.display = 'none';
            renameGridContainer.innerHTML = '';
            downloadAllRenamed.style.display = 'none';
            targetFormat.value = 'png';
        });

        /* ======= å›¾ç‰‡å åŠ å·¥å…· ======= */
        let backgroundImg = null;
        let overlayImg = null;
        let overlayX = 0;
        let overlayY = 0;
        let overlayWidth = 0;
        let overlayHeight = 0;
        let overlayOpacityValue = 1;
        let isDragging = false;
        let isResizing = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let resizeCorner = null;
        let overlayAspectRatio = 1;

        const uploadBackground = document.getElementById("uploadBackground");
        const uploadOverlayImg = document.getElementById("uploadOverlay");
        const dropBackground = document.getElementById("dropBackground");
        const dropOverlayArea = document.getElementById("dropOverlay");
        const overlayCanvas = document.getElementById("overlayCanvas");
        const overlayPlaceholder = document.getElementById("overlayPlaceholder");
        const ctx = overlayCanvas.getContext("2d");

        const centerHorizontalBtn = document.getElementById("centerHorizontal");
        const centerVerticalBtn = document.getElementById("centerVertical");
        const centerBothBtn = document.getElementById("centerBoth");
        const resetOverlayBtn = document.getElementById("resetOverlay");
        const fitToBackgroundBtn = document.getElementById("fitToBackground");
        const overlayOpacitySlider = document.getElementById("overlayOpacity");
        const opacityValueSpan = document.getElementById("opacityValue");
        const downloadOverlayBtn = document.getElementById("downloadOverlay");

        // ä¸Šä¼ èƒŒæ™¯å›¾ç‰‡
        function handleBackgroundUpload(file) {
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    backgroundImg = img;
                    initializeCanvas();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // ä¸Šä¼ å åŠ å›¾ç‰‡
        function handleOverlayUpload(file) {
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    overlayImg = img;
                    overlayAspectRatio = img.width / img.height;
                    initializeCanvas();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // åˆå§‹åŒ–ç”»å¸ƒ
        function initializeCanvas() {
            if (!backgroundImg) return;

            // è®¾ç½®ç”»å¸ƒå¤§å°ä¸ºèƒŒæ™¯å›¾ç‰‡å¤§å°
            overlayCanvas.width = backgroundImg.width;
            overlayCanvas.height = backgroundImg.height;

            overlayCanvas.style.display = 'block';
            overlayPlaceholder.style.display = 'none';

            // å¦‚æœæœ‰å åŠ å›¾ç‰‡ï¼Œåˆå§‹åŒ–å…¶ä½ç½®å’Œå¤§å°
            if (overlayImg) {
                const scale = Math.min(
                    (backgroundImg.width * 0.5) / overlayImg.width,
                    (backgroundImg.height * 0.5) / overlayImg.height
                );
                overlayWidth = overlayImg.width * scale;
                overlayHeight = overlayImg.height * scale;
                overlayX = (backgroundImg.width - overlayWidth) / 2;
                overlayY = (backgroundImg.height - overlayHeight) / 2;

                // å¯ç”¨æ‰€æœ‰æ§åˆ¶æŒ‰é’®
                centerHorizontalBtn.disabled = false;
                centerVerticalBtn.disabled = false;
                centerBothBtn.disabled = false;
                resetOverlayBtn.disabled = false;
                fitToBackgroundBtn.disabled = false;
                overlayOpacitySlider.disabled = false;
                downloadOverlayBtn.disabled = false;
            }

            drawCanvas();
        }

        // ç»˜åˆ¶ç”»å¸ƒ
        function drawCanvas() {
            if (!backgroundImg) return;

            ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

            // ç»˜åˆ¶èƒŒæ™¯å›¾ç‰‡
            ctx.drawImage(backgroundImg, 0, 0);

            // å¦‚æœæœ‰å åŠ å›¾ç‰‡ï¼Œç»˜åˆ¶å åŠ å›¾ç‰‡åŠæ§åˆ¶å…ƒç´ 
            if (overlayImg) {
                // ç»˜åˆ¶å åŠ å›¾ç‰‡
                ctx.globalAlpha = overlayOpacityValue;
                ctx.drawImage(overlayImg, overlayX, overlayY, overlayWidth, overlayHeight);
                ctx.globalAlpha = 1;

                // ç»˜åˆ¶å åŠ å›¾ç‰‡çš„è¾¹æ¡†å’Œæ§åˆ¶ç‚¹
                ctx.strokeStyle = '#0078d4';
                ctx.lineWidth = 2;
                ctx.strokeRect(overlayX, overlayY, overlayWidth, overlayHeight);

                // ç»˜åˆ¶å››ä¸ªè§’çš„æ§åˆ¶ç‚¹
                const corners = [
                    { x: overlayX, y: overlayY, cursor: 'nw-resize' },
                    { x: overlayX + overlayWidth, y: overlayY, cursor: 'ne-resize' },
                    { x: overlayX, y: overlayY + overlayHeight, cursor: 'sw-resize' },
                    { x: overlayX + overlayWidth, y: overlayY + overlayHeight, cursor: 'se-resize' }
                ];

                ctx.fillStyle = '#0078d4';
                corners.forEach(corner => {
                    ctx.fillRect(corner.x - 5, corner.y - 5, 10, 10);
                });
            }
        }

        // è·å–é¼ æ ‡åœ¨ç”»å¸ƒä¸Šçš„ä½ç½®
        function getMousePos(e) {
            const rect = overlayCanvas.getBoundingClientRect();
            const scaleX = overlayCanvas.width / rect.width;
            const scaleY = overlayCanvas.height / rect.height;

            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        // æ£€æŸ¥æ˜¯å¦åœ¨æ§åˆ¶ç‚¹ä¸Š
        function getResizeCorner(x, y) {
            const corners = [
                { x: overlayX, y: overlayY, name: 'nw' },
                { x: overlayX + overlayWidth, y: overlayY, name: 'ne' },
                { x: overlayX, y: overlayY + overlayHeight, name: 'sw' },
                { x: overlayX + overlayWidth, y: overlayY + overlayHeight, name: 'se' }
            ];

            for (let corner of corners) {
                const distance = Math.sqrt((x - corner.x) ** 2 + (y - corner.y) ** 2);
                if (distance < 10) {
                    return corner.name;
                }
            }
            return null;
        }

        // é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
        overlayCanvas.addEventListener('mousedown', (e) => {
            if (!backgroundImg || !overlayImg) return;

            const pos = getMousePos(e);
            resizeCorner = getResizeCorner(pos.x, pos.y);

            if (resizeCorner) {
                isResizing = true;
                dragStartX = pos.x;
                dragStartY = pos.y;
            } else if (pos.x >= overlayX && pos.x <= overlayX + overlayWidth &&
                pos.y >= overlayY && pos.y <= overlayY + overlayHeight) {
                isDragging = true;
                dragStartX = pos.x - overlayX;
                dragStartY = pos.y - overlayY;
            }
        });

        // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
        overlayCanvas.addEventListener('mousemove', (e) => {
            if (!backgroundImg || !overlayImg) return;

            const pos = getMousePos(e);

            if (isDragging) {
                overlayX = pos.x - dragStartX;
                overlayY = pos.y - dragStartY;

                // é™åˆ¶åœ¨ç”»å¸ƒèŒƒå›´å†…
                overlayX = Math.max(0, Math.min(overlayX, overlayCanvas.width - overlayWidth));
                overlayY = Math.max(0, Math.min(overlayY, overlayCanvas.height - overlayHeight));

                drawCanvas();
            } else if (isResizing) {
                const deltaX = pos.x - dragStartX;
                const deltaY = pos.y - dragStartY;

                let newWidth = overlayWidth;
                let newHeight = overlayHeight;
                let newX = overlayX;
                let newY = overlayY;

                // æ ¹æ®æ‹–æ‹½çš„è§’è®¡ç®—æ–°çš„å°ºå¯¸ï¼Œä¿æŒçºµæ¨ªæ¯”
                if (resizeCorner === 'se') {
                    newWidth = overlayWidth + deltaX;
                    newHeight = newWidth / overlayAspectRatio;
                } else if (resizeCorner === 'sw') {
                    newWidth = overlayWidth - deltaX;
                    newHeight = newWidth / overlayAspectRatio;
                    newX = overlayX + deltaX;
                } else if (resizeCorner === 'ne') {
                    newWidth = overlayWidth + deltaX;
                    newHeight = newWidth / overlayAspectRatio;
                    newY = overlayY - (newHeight - overlayHeight);
                } else if (resizeCorner === 'nw') {
                    newWidth = overlayWidth - deltaX;
                    newHeight = newWidth / overlayAspectRatio;
                    newX = overlayX + deltaX;
                    newY = overlayY - (newHeight - overlayHeight);
                }

                // ç¡®ä¿å°ºå¯¸ä¸å°äº10px
                if (newWidth > 10 && newHeight > 10) {
                    overlayWidth = newWidth;
                    overlayHeight = newHeight;
                    overlayX = newX;
                    overlayY = newY;
                    dragStartX = pos.x;
                    dragStartY = pos.y;
                    drawCanvas();
                }
            } else {
                // æ›´æ–°é¼ æ ‡æ ·å¼
                const corner = getResizeCorner(pos.x, pos.y);
                if (corner) {
                    overlayCanvas.style.cursor = corner + '-resize';
                } else if (pos.x >= overlayX && pos.x <= overlayX + overlayWidth &&
                    pos.y >= overlayY && pos.y <= overlayY + overlayHeight) {
                    overlayCanvas.style.cursor = 'move';
                } else {
                    overlayCanvas.style.cursor = 'default';
                }
            }
        });

        // é¼ æ ‡é‡Šæ”¾äº‹ä»¶
        overlayCanvas.addEventListener('mouseup', () => {
            isDragging = false;
            isResizing = false;
            resizeCorner = null;
        });

        overlayCanvas.addEventListener('mouseleave', () => {
            isDragging = false;
            isResizing = false;
            resizeCorner = null;
        });

        // æ°´å¹³å±…ä¸­
        centerHorizontalBtn.addEventListener('click', () => {
            overlayX = (overlayCanvas.width - overlayWidth) / 2;
            drawCanvas();
        });

        // å‚ç›´å±…ä¸­
        centerVerticalBtn.addEventListener('click', () => {
            overlayY = (overlayCanvas.height - overlayHeight) / 2;
            drawCanvas();
        });

        // å®Œå…¨å±…ä¸­
        centerBothBtn.addEventListener('click', () => {
            overlayX = (overlayCanvas.width - overlayWidth) / 2;
            overlayY = (overlayCanvas.height - overlayHeight) / 2;
            drawCanvas();
        });

        // é‡ç½®ä½ç½®
        resetOverlayBtn.addEventListener('click', () => {
            if (!backgroundImg || !overlayImg) return;

            const scale = Math.min(
                (backgroundImg.width * 0.5) / overlayImg.width,
                (backgroundImg.height * 0.5) / overlayImg.height
            );
            overlayWidth = overlayImg.width * scale;
            overlayHeight = overlayImg.height * scale;
            overlayX = (backgroundImg.width - overlayWidth) / 2;
            overlayY = (backgroundImg.height - overlayHeight) / 2;

            drawCanvas();
        });

        // é€‚åº”èƒŒæ™¯
        fitToBackgroundBtn.addEventListener('click', () => {
            if (!backgroundImg || !overlayImg) return;

            const scale = Math.min(
                backgroundImg.width / overlayImg.width,
                backgroundImg.height / overlayImg.height
            );
            overlayWidth = overlayImg.width * scale;
            overlayHeight = overlayImg.height * scale;
            overlayX = (backgroundImg.width - overlayWidth) / 2;
            overlayY = (backgroundImg.height - overlayHeight) / 2;

            drawCanvas();
        });

        // ä¸é€æ˜åº¦è°ƒæ•´
        overlayOpacitySlider.addEventListener('input', () => {
            overlayOpacityValue = overlayOpacitySlider.value / 100;
            opacityValueSpan.textContent = overlayOpacitySlider.value + '%';
            drawCanvas();
        });

        // ä¸‹è½½åˆæˆå›¾ç‰‡
        downloadOverlayBtn.addEventListener('click', () => {
            if (!backgroundImg || !overlayImg) return;

            // åˆ›å»ºæœ€ç»ˆåˆæˆçš„canvas
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = overlayCanvas.width;
            finalCanvas.height = overlayCanvas.height;
            const finalCtx = finalCanvas.getContext('2d');

            // ç»˜åˆ¶èƒŒæ™¯
            finalCtx.drawImage(backgroundImg, 0, 0);

            // ç»˜åˆ¶å åŠ å›¾ç‰‡
            finalCtx.globalAlpha = overlayOpacityValue;
            finalCtx.drawImage(overlayImg, overlayX, overlayY, overlayWidth, overlayHeight);
            finalCtx.globalAlpha = 1;

            // ä¸‹è½½
            finalCanvas.toBlob(blob => {
                const link = document.createElement('a');
                link.download = 'overlay_result.png';
                link.href = URL.createObjectURL(blob);
                link.click();
            });
        });

        // æ–‡ä»¶ä¸Šä¼ äº‹ä»¶
        uploadBackground.addEventListener('change', e => handleBackgroundUpload(e.target.files[0]));
        uploadOverlayImg.addEventListener('change', e => handleOverlayUpload(e.target.files[0]));

        // æ‹–æ‹½ä¸Šä¼  - èƒŒæ™¯å›¾ç‰‡
        dropBackground.addEventListener('dragover', e => {
            e.preventDefault();
            dropBackground.classList.add('hover');
        });

        dropBackground.addEventListener('dragleave', e => {
            e.preventDefault();
            dropBackground.classList.remove('hover');
        });

        dropBackground.addEventListener('drop', e => {
            e.preventDefault();
            dropBackground.classList.remove('hover');
            handleBackgroundUpload(e.dataTransfer.files[0]);
        });

        // æ‹–æ‹½ä¸Šä¼  - å åŠ å›¾ç‰‡
        dropOverlayArea.addEventListener('dragover', e => {
            e.preventDefault();
            dropOverlayArea.classList.add('hover');
        });

        dropOverlayArea.addEventListener('dragleave', e => {
            e.preventDefault();
            dropOverlayArea.classList.remove('hover');
        });

        dropOverlayArea.addEventListener('drop', e => {
            e.preventDefault();
            dropOverlayArea.classList.remove('hover');
            handleOverlayUpload(e.dataTransfer.files[0]);
        });

        // é‡ç½®å›¾ç‰‡å åŠ å·¥å…·
        const resetOverlayToolBtn = document.getElementById('resetOverlayTool');
        resetOverlayToolBtn.addEventListener('click', () => {
            // æ¸…ç©ºå›¾ç‰‡
            backgroundImg = null;
            overlayImg = null;
            overlayX = 0;
            overlayY = 0;
            overlayWidth = 0;
            overlayHeight = 0;
            overlayOpacityValue = 1;
            isDragging = false;
            isResizing = false;
            resizeCorner = null;
            overlayAspectRatio = 1;

            // æ¸…ç©ºè¾“å…¥
            uploadBackground.value = '';
            uploadOverlayImg.value = '';

            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            overlayCanvas.style.display = 'none';
            overlayPlaceholder.style.display = 'block';

            // ç¦ç”¨æŒ‰é’®
            centerHorizontalBtn.disabled = true;
            centerVerticalBtn.disabled = true;
            centerBothBtn.disabled = true;
            resetOverlayBtn.disabled = true;
            fitToBackgroundBtn.disabled = true;
            overlayOpacitySlider.disabled = true;
            downloadOverlayBtn.disabled = true;

            // é‡ç½®ä¸é€æ˜åº¦
            overlayOpacitySlider.value = 100;
            opacityValueSpan.textContent = '100%';
        });

        /* ======= å›¾ç‰‡æ‹¼æ¥å·¥å…· ======= */
        let stitchImages = [];
        let stitchImagesData = [];
        let draggedIndex = null;

        const uploadStitch = document.getElementById("uploadStitch");
        const dropStitch = document.getElementById("dropStitch");
        const stitchImageList = document.getElementById("stitchImageList");
        const stitchListContainer = document.getElementById("stitchListContainer");
        const stitchUploadCount = document.getElementById("stitchUploadCount");
        const stitchMode = document.getElementById("stitchMode");
        const stitchGap = document.getElementById("stitchGap");
        const stitchBgColor = document.getElementById("stitchBgColor");
        const stitchCanvas = document.getElementById("stitchCanvas");
        const stitchPlaceholder = document.getElementById("stitchPlaceholder");
        const downloadStitchBtn = document.getElementById("downloadStitch");
        const resetStitchBtn = document.getElementById("resetStitch");
        const stitchModeBtns = document.querySelectorAll(".stitch-mode-btn");
        const stitchCtx = stitchCanvas.getContext("2d");

        // æ¨¡å¼æŒ‰é’®ç‚¹å‡»
        stitchModeBtns.forEach(btn => {
            btn.addEventListener("click", () => {
                const mode = btn.getAttribute("data-mode");
                stitchMode.value = mode;
                if (stitchImagesData.length >= 2) {
                    stitchImagesFunc();
                }
            });
        });

        // å¤„ç†ä¸Šä¼ çš„æ–‡ä»¶
        function handleStitchFiles(files) {
            if (!files || files.length === 0) return;

            const validFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
            if (validFiles.length === 0) return;

            // åŠ è½½å›¾ç‰‡
            const loadPromises = validFiles.map(file => {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            resolve({ file, img, url: e.target.result });
                        };
                        img.onerror = () => resolve(null);
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            });

            Promise.all(loadPromises).then(results => {
                const validResults = results.filter(r => r !== null);
                stitchImagesData = stitchImagesData.concat(validResults);
                updateStitchList();

                if (stitchImagesData.length >= 2) {
                    stitchImagesFunc();
                }
            });
        }

        // æ›´æ–°å›¾ç‰‡åˆ—è¡¨æ˜¾ç¤º
        function updateStitchList() {
            if (stitchImagesData.length === 0) {
                stitchImageList.style.display = 'none';
                return;
            }

            stitchImageList.style.display = 'block';
            stitchUploadCount.textContent = `${stitchImagesData.length} å¼ `;
            stitchListContainer.innerHTML = '';

            stitchImagesData.forEach((data, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.draggable = true;
                itemDiv.dataset.index = index;
                itemDiv.style.cssText = `
      position: relative;
      width: 100px;
      height: 100px;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      overflow: hidden;
      cursor: move;
      transition: all 0.3s ease;
      background: #fff;
    `;

                const img = document.createElement('img');
                img.src = data.url;
                img.style.cssText = `
      width: 100%;
      height: 100%;
      object-fit: cover;
    `;

                const orderBadge = document.createElement('div');
                orderBadge.textContent = index + 1;
                orderBadge.style.cssText = `
      position: absolute;
      top: 5px;
      left: 5px;
      background: #0078d4;
      color: #fff;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
    `;

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Ã—';
                deleteBtn.style.cssText = `
      position: absolute;
      top: 5px;
      right: 5px;
      background: #dc3545;
      color: #fff;
      border: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 18px;
      line-height: 20px;
      padding: 0;
    `;

                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    stitchImagesData.splice(index, 1);
                    updateStitchList();
                    if (stitchImagesData.length < 2) {
                        downloadStitchBtn.disabled = true;
                        stitchCanvas.style.display = 'none';
                        stitchPlaceholder.style.display = 'block';
                    } else {
                        stitchImagesFunc();
                    }
                });

                // æ‹–æ‹½äº‹ä»¶
                itemDiv.addEventListener('dragstart', (e) => {
                    draggedIndex = index;
                    itemDiv.style.opacity = '0.5';
                });

                itemDiv.addEventListener('dragend', (e) => {
                    itemDiv.style.opacity = '1';
                });

                itemDiv.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    itemDiv.style.borderColor = '#0078d4';
                });

                itemDiv.addEventListener('dragleave', (e) => {
                    itemDiv.style.borderColor = '#dee2e6';
                });

                itemDiv.addEventListener('drop', (e) => {
                    e.preventDefault();
                    itemDiv.style.borderColor = '#dee2e6';

                    if (draggedIndex !== null && draggedIndex !== index) {
                        const draggedItem = stitchImagesData[draggedIndex];
                        stitchImagesData.splice(draggedIndex, 1);
                        stitchImagesData.splice(index, 0, draggedItem);
                        updateStitchList();
                        draggedIndex = null;
                        if (stitchImagesData.length >= 2) {
                            stitchImagesFunc();
                        }
                    }
                });

                itemDiv.addEventListener('mouseenter', () => {
                    itemDiv.style.transform = 'scale(1.05)';
                    itemDiv.style.borderColor = '#0078d4';
                });

                itemDiv.addEventListener('mouseleave', () => {
                    itemDiv.style.transform = 'scale(1)';
                    itemDiv.style.borderColor = '#dee2e6';
                });

                itemDiv.appendChild(img);
                itemDiv.appendChild(orderBadge);
                itemDiv.appendChild(deleteBtn);
                stitchListContainer.appendChild(itemDiv);
            });
        }

        // æ‹¼æ¥å›¾ç‰‡
        function stitchImagesFunc() {
            if (stitchImagesData.length < 2) return;

            const mode = stitchMode.value;
            const gap = parseInt(stitchGap.value) || 0;
            const bgColor = stitchBgColor.value;

            let canvasWidth = 0;
            let canvasHeight = 0;
            let positions = [];

            if (mode === 'horizontal') {
                // æ°´å¹³æ‹¼æ¥
                const maxHeight = Math.max(...stitchImagesData.map(d => d.img.height));
                canvasWidth = stitchImagesData.reduce((sum, d) => sum + d.img.width, 0) + gap * (stitchImagesData.length - 1);
                canvasHeight = maxHeight;

                let x = 0;
                stitchImagesData.forEach(data => {
                    positions.push({ x, y: (maxHeight - data.img.height) / 2, width: data.img.width, height: data.img.height, img: data.img });
                    x += data.img.width + gap;
                });
            } else if (mode === 'vertical') {
                // å‚ç›´æ‹¼æ¥
                const maxWidth = Math.max(...stitchImagesData.map(d => d.img.width));
                canvasWidth = maxWidth;
                canvasHeight = stitchImagesData.reduce((sum, d) => sum + d.img.height, 0) + gap * (stitchImagesData.length - 1);

                let y = 0;
                stitchImagesData.forEach(data => {
                    positions.push({ x: (maxWidth - data.img.width) / 2, y, width: data.img.width, height: data.img.height, img: data.img });
                    y += data.img.height + gap;
                });
            } else if (mode.startsWith('row')) {
                // ä¸€è¡ŒNä¸ªçš„ç½‘æ ¼å¸ƒå±€
                const perRow = parseInt(mode.replace('row', ''));
                const totalImages = stitchImagesData.length;
                const rows = Math.ceil(totalImages / perRow);

                // è®¡ç®—æ¯ä¸ªå•å…ƒæ ¼çš„å¤§å°ï¼ˆå–æœ€å¤§å®½é«˜ï¼‰
                const maxWidth = Math.max(...stitchImagesData.map(d => d.img.width));
                const maxHeight = Math.max(...stitchImagesData.map(d => d.img.height));

                canvasWidth = maxWidth * perRow + gap * (perRow - 1);
                canvasHeight = maxHeight * rows + gap * (rows - 1);

                stitchImagesData.forEach((data, index) => {
                    const row = Math.floor(index / perRow);
                    const col = index % perRow;

                    // è®¡ç®—å½“å‰è¡Œæœ‰å¤šå°‘ä¸ªå›¾ç‰‡
                    const imagesInCurrentRow = (row === rows - 1) ? (totalImages % perRow || perRow) : perRow;

                    // å¦‚æœæ˜¯æœ€åä¸€è¡Œä¸”ä¸æ»¡ï¼Œå±…ä¸­æ˜¾ç¤º
                    let offsetX = 0;
                    if (imagesInCurrentRow < perRow) {
                        offsetX = ((perRow - imagesInCurrentRow) * (maxWidth + gap)) / 2;
                    }

                    const x = offsetX + col * (maxWidth + gap) + (maxWidth - data.img.width) / 2;
                    const y = row * (maxHeight + gap) + (maxHeight - data.img.height) / 2;
                    positions.push({ x, y, width: data.img.width, height: data.img.height, img: data.img });
                });
            }

            // ç»˜åˆ¶åˆ°ç”»å¸ƒ
            stitchCanvas.width = canvasWidth;
            stitchCanvas.height = canvasHeight;

            // å¡«å……èƒŒæ™¯è‰²
            stitchCtx.fillStyle = bgColor;
            stitchCtx.fillRect(0, 0, canvasWidth, canvasHeight);

            // ç»˜åˆ¶æ‰€æœ‰å›¾ç‰‡
            positions.forEach(pos => {
                stitchCtx.drawImage(pos.img, pos.x, pos.y, pos.width, pos.height);
            });

            stitchCanvas.style.display = 'block';
            stitchPlaceholder.style.display = 'none';
            downloadStitchBtn.disabled = false;
        }

        // å‚æ•°æ”¹å˜æ—¶è‡ªåŠ¨é¢„è§ˆ
        stitchMode.addEventListener("change", () => {
            if (stitchImagesData.length >= 2 && stitchCanvas.style.display === 'block') {
                stitchImagesFunc();
            }
        });

        stitchGap.addEventListener("input", () => {
            if (stitchImagesData.length >= 2 && stitchCanvas.style.display === 'block') {
                stitchImagesFunc();
            }
        });

        stitchBgColor.addEventListener("input", () => {
            if (stitchImagesData.length >= 2 && stitchCanvas.style.display === 'block') {
                stitchImagesFunc();
            }
        });

        // ä¸‹è½½æ‹¼æ¥å›¾ç‰‡
        downloadStitchBtn.addEventListener("click", () => {
            if (stitchImagesData.length < 2) return;

            stitchCanvas.toBlob(blob => {
                const link = document.createElement('a');
                link.download = 'stitched_image.png';
                link.href = URL.createObjectURL(blob);
                link.click();
            });
        });

        // é‡ç½®
        resetStitchBtn.addEventListener("click", () => {
            stitchImagesData = [];
            uploadStitch.value = '';
            stitchImageList.style.display = 'none';
            stitchListContainer.innerHTML = '';
            stitchCanvas.style.display = 'none';
            stitchPlaceholder.style.display = 'block';
            downloadStitchBtn.disabled = true;
            stitchMode.value = 'row3';
            stitchGap.value = 0;
            stitchBgColor.value = '#ffffff';
        });

        // æ–‡ä»¶ä¸Šä¼ äº‹ä»¶
        uploadStitch.addEventListener("change", e => handleStitchFiles(e.target.files));

        // æ‹–æ‹½ä¸Šä¼ 
        dropStitch.addEventListener('dragover', e => {
            e.preventDefault();
            dropStitch.classList.add('hover');
        });

        dropStitch.addEventListener('dragleave', e => {
            e.preventDefault();
            dropStitch.classList.remove('hover');
        });

        dropStitch.addEventListener('drop', e => {
            e.preventDefault();
            dropStitch.classList.remove('hover');
            handleStitchFiles(e.dataTransfer.files);
        });

        /* ======= GIFåˆ¶ä½œå·¥å…· ======= */
        let gifImagesData = [];
        let gifDraggedIndex = null;
        let generatedGifBlob = null;

        const uploadGif = document.getElementById("uploadGif");
        const dropGif = document.getElementById("dropGif");
        const gifImageList = document.getElementById("gifImageList");
        const gifListContainer = document.getElementById("gifListContainer");
        const gifUploadCount = document.getElementById("gifUploadCount");
        const gifDelay = document.getElementById("gifDelay");
        const gifQuality = document.getElementById("gifQuality");
        const gifQualityValue = document.getElementById("gifQualityValue");
        const gifRepeat = document.getElementById("gifRepeat");
        const generateGifBtn = document.getElementById("generateGif");
        const downloadGifBtn = document.getElementById("downloadGif");
        const resetGifBtn = document.getElementById("resetGif");
        const gifDelayBtns = document.querySelectorAll(".gif-delay-btn");
        const gifPreview = document.getElementById("gifPreview");
        const gifPreviewImg = document.getElementById("gifPreviewImg");
        const gifPlaceholder = document.getElementById("gifPlaceholder");
        const gifProgress = document.getElementById("gifProgress");
        const gifProgressBar = document.getElementById("gifProgressBar");
        const gifProgressText = document.getElementById("gifProgressText");

        // è´¨é‡æ»‘å—æ›´æ–°
        gifQuality.addEventListener("input", () => {
            gifQualityValue.textContent = gifQuality.value;
        });

        // å»¶è¿ŸæŒ‰é’®ç‚¹å‡»
        gifDelayBtns.forEach(btn => {
            btn.addEventListener("click", () => {
                const delay = btn.getAttribute("data-delay");
                gifDelay.value = delay;
            });
        });

        // å¤„ç†ä¸Šä¼ çš„æ–‡ä»¶
        function handleGifFiles(files) {
            if (!files || files.length === 0) return;

            const validFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
            if (validFiles.length === 0) return;

            // åŠ è½½å›¾ç‰‡
            const loadPromises = validFiles.map(file => {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            resolve({ file, img, url: e.target.result });
                        };
                        img.onerror = () => resolve(null);
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            });

            Promise.all(loadPromises).then(results => {
                const validResults = results.filter(r => r !== null);
                gifImagesData = gifImagesData.concat(validResults);
                updateGifList();

                if (gifImagesData.length >= 2) {
                    generateGifBtn.disabled = false;
                }
            });
        }

        // æ›´æ–°å›¾ç‰‡åˆ—è¡¨æ˜¾ç¤º
        function updateGifList() {
            if (gifImagesData.length === 0) {
                gifImageList.style.display = 'none';
                return;
            }

            gifImageList.style.display = 'block';
            gifUploadCount.textContent = `${gifImagesData.length} å¸§`;
            gifListContainer.innerHTML = '';

            gifImagesData.forEach((data, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.draggable = true;
                itemDiv.dataset.index = index;
                itemDiv.style.cssText = `
      position: relative;
      width: 100px;
      height: 100px;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      overflow: hidden;
      cursor: move;
      transition: all 0.3s ease;
      background: #fff;
    `;

                const img = document.createElement('img');
                img.src = data.url;
                img.style.cssText = `
      width: 100%;
      height: 100%;
      object-fit: cover;
    `;

                const orderBadge = document.createElement('div');
                orderBadge.textContent = index + 1;
                orderBadge.style.cssText = `
      position: absolute;
      top: 5px;
      left: 5px;
      background: #0078d4;
      color: #fff;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
    `;

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Ã—';
                deleteBtn.style.cssText = `
      position: absolute;
      top: 5px;
      right: 5px;
      background: #dc3545;
      color: #fff;
      border: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 18px;
      line-height: 20px;
      padding: 0;
    `;

                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    gifImagesData.splice(index, 1);
                    updateGifList();
                    if (gifImagesData.length < 2) {
                        generateGifBtn.disabled = true;
                        downloadGifBtn.disabled = true;
                        gifPreview.style.display = 'none';
                        gifPlaceholder.style.display = 'block';
                    }
                });

                // æ‹–æ‹½äº‹ä»¶
                itemDiv.addEventListener('dragstart', (e) => {
                    gifDraggedIndex = index;
                    itemDiv.style.opacity = '0.5';
                });

                itemDiv.addEventListener('dragend', (e) => {
                    itemDiv.style.opacity = '1';
                });

                itemDiv.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    itemDiv.style.borderColor = '#0078d4';
                });

                itemDiv.addEventListener('dragleave', (e) => {
                    itemDiv.style.borderColor = '#dee2e6';
                });

                itemDiv.addEventListener('drop', (e) => {
                    e.preventDefault();
                    itemDiv.style.borderColor = '#dee2e6';

                    if (gifDraggedIndex !== null && gifDraggedIndex !== index) {
                        const draggedItem = gifImagesData[gifDraggedIndex];
                        gifImagesData.splice(gifDraggedIndex, 1);
                        gifImagesData.splice(index, 0, draggedItem);
                        updateGifList();
                        gifDraggedIndex = null;
                    }
                });

                itemDiv.addEventListener('mouseenter', () => {
                    itemDiv.style.transform = 'scale(1.05)';
                    itemDiv.style.borderColor = '#0078d4';
                });

                itemDiv.addEventListener('mouseleave', () => {
                    itemDiv.style.transform = 'scale(1)';
                    itemDiv.style.borderColor = '#dee2e6';
                });

                itemDiv.appendChild(img);
                itemDiv.appendChild(orderBadge);
                itemDiv.appendChild(deleteBtn);
                gifListContainer.appendChild(itemDiv);
            });
        }

        // ç”ŸæˆGIF
        generateGifBtn.addEventListener("click", () => {
            if (gifImagesData.length < 2) return;

            // æ£€æŸ¥gifshotæ˜¯å¦åŠ è½½
            if (typeof gifshot === 'undefined') {
                alert('GIFåº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                return;
            }

            const delay = parseInt(gifDelay.value) || 500;
            const interval = delay / 1000; // è½¬æ¢ä¸ºç§’
            const numFrames = gifImagesData.length;

            // æ˜¾ç¤ºè¿›åº¦æ¡
            gifProgress.style.display = 'block';
            gifProgressBar.style.width = '10%';
            gifProgressBar.textContent = '10%';
            gifProgressText.textContent = 'æ­£åœ¨ç”ŸæˆGIF...';
            generateGifBtn.disabled = true;

            // å‡†å¤‡å›¾ç‰‡URLæ•°ç»„
            const imageUrls = gifImagesData.map(d => d.url);

            // ä½¿ç”¨gifshotç”ŸæˆGIF
            gifshot.createGIF({
                images: imageUrls,
                gifWidth: Math.max(...gifImagesData.map(d => d.img.width)),
                gifHeight: Math.max(...gifImagesData.map(d => d.img.height)),
                interval: interval,
                numFrames: numFrames,
                frameDuration: 1,
                sampleInterval: 10,
                numWorkers: 2
            }, function (obj) {
                if (!obj.error) {
                    // æ›´æ–°è¿›åº¦
                    gifProgressBar.style.width = '100%';
                    gifProgressBar.textContent = '100%';
                    gifProgressText.textContent = 'âœ“ GIFç”Ÿæˆå®Œæˆï¼';

                    // å°†base64è½¬æ¢ä¸ºblob
                    const base64Data = obj.image.split(',')[1];
                    const byteCharacters = atob(base64Data);
                    const byteArrays = [];

                    for (let i = 0; i < byteCharacters.length; i++) {
                        byteArrays.push(byteCharacters.charCodeAt(i));
                    }

                    generatedGifBlob = new Blob([new Uint8Array(byteArrays)], { type: 'image/gif' });

                    // æ˜¾ç¤ºé¢„è§ˆ
                    gifPreviewImg.src = obj.image;
                    gifPreview.style.display = 'block';
                    gifPlaceholder.style.display = 'none';

                    downloadGifBtn.disabled = false;
                    generateGifBtn.disabled = false;

                    // 3ç§’åéšè—è¿›åº¦æ¡
                    setTimeout(() => {
                        gifProgress.style.display = 'none';
                    }, 3000);
                } else {
                    gifProgressText.textContent = 'âœ— ç”Ÿæˆå¤±è´¥ï¼Œè¯·é‡è¯•';
                    generateGifBtn.disabled = false;
                    console.error('GIFç”Ÿæˆé”™è¯¯:', obj.error);
                }
            });

            // æ¨¡æ‹Ÿè¿›åº¦æ›´æ–°
            let progress = 10;
            const progressInterval = setInterval(() => {
                if (progress < 90) {
                    progress += 10;
                    gifProgressBar.style.width = progress + '%';
                    gifProgressBar.textContent = progress + '%';
                } else {
                    clearInterval(progressInterval);
                }
            }, 200);
        });

        // ä¸‹è½½GIF
        downloadGifBtn.addEventListener("click", () => {
            if (!generatedGifBlob) return;

            const link = document.createElement('a');
            link.download = 'animated.gif';
            link.href = URL.createObjectURL(generatedGifBlob);
            link.click();
        });

        // é‡ç½®
        resetGifBtn.addEventListener("click", () => {
            gifImagesData = [];
            generatedGifBlob = null;
            uploadGif.value = '';
            gifImageList.style.display = 'none';
            gifListContainer.innerHTML = '';
            gifPreview.style.display = 'none';
            gifPlaceholder.style.display = 'block';
            gifProgress.style.display = 'none';
            generateGifBtn.disabled = true;
            downloadGifBtn.disabled = true;
            gifDelay.value = 500;
            gifQuality.value = 10;
            gifQualityValue.textContent = '10';
            gifRepeat.checked = true;
        });

        // æ–‡ä»¶ä¸Šä¼ äº‹ä»¶
        uploadGif.addEventListener("change", e => handleGifFiles(e.target.files));

        // æ‹–æ‹½ä¸Šä¼ 
        dropGif.addEventListener('dragover', e => {
            e.preventDefault();
            dropGif.classList.add('hover');
        });

        dropGif.addEventListener('dragleave', e => {
            e.preventDefault();
            dropGif.classList.remove('hover');
        });

        dropGif.addEventListener('drop', e => {
            e.preventDefault();
            dropGif.classList.remove('hover');
            handleGifFiles(e.dataTransfer.files);
        });
    </script>
</body>

</html>